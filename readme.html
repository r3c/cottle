<html>
	<head>
		<style type="text/css">
			body {
				padding:	0px;
				margin:		32px 64px;
				font:		normal normal normal 0.9em 'Trebuchet MS', Helvetica, sans-serif;
			}

			div.code {
				padding:		0px 6px 1px 6px;
				margin:			12px 8px;
				background:		#D0E0F0;
				border-top:		1px solid #80A0B0;
				border-right:	1px solid #A0C0D0;
				border-bottom:	1px solid #A0C0D0;
				border-left:	1px solid #80A0B0;
				border-radius:	6px;
			}

			div.code code {
				font:			normal normal normal 1.0em monospace;
				white-space:	pre;
			}

			div.code legend {
				position:	relative;
				top:		-4px;
			}

			div.code legend span {
				padding:		0px 4px 0px 5px;
				background:		#B0C6E0;
				border-top:		1px solid #C0D0F0;
				border-right:	1px solid #A0B0C0;
				border-bottom:	1px solid #A0B0C0;
				border-left:	1px solid #C0D0F0;
				border-radius:	6px;
				font-size:		0.7em;
				font-weight:	bold;
			}

			div.s1 {
				margin:		8px 0px 48px 0px;
			}

			div.s2 {
				margin:		8px 0px 32px 0px;
			}

			div.s3 {
				margin:		8px 0px 24px 0px;
			}

			h1 {
				padding:	0px;
				margin:		24px 8px;
				text-align:	center;				
				font-size:	2.0em;
				color:		#4060A0;
			}

			h2 {
				padding:	0px;
				margin:		8px 16px;
				font-size:	1.4em;
				color:		#5070B0;
			}

			h3 {
				padding:	0px;
				margin:		8px 24px;
				font-size:	1.0em;
				color:		#6080C0;
			}

			p {
				margin:	12px 8px;
			}

			p code {
				background:	#E0E0E0;
				font:		normal normal normal 1.0em monospace;
			}

			ul {
				padding:	4px 32px;
				margin:		8px 0px;
				list-style:	circle;
			}

			ul code {
				background:	#E0E0E0;
				font:		normal normal normal 1.0em monospace;
			}
		</style>
		<title>Cottle Documentation</title>
	</head>
	<body>
		<h1>Cottle Documentation</h1>

		<a name="1" />
		<h2>1. Cottle overview</h2>
		<div class="s2">
			<a name="1.1" />
			<h3>1.1. What is Cottle, and what does it looks like?</h3>
			<div class="s3">
				<p>Cottle, short for "<u>C</u>ompact <u>O</u>bject to
				<u>T</u>ext <u>T</u>ransform <u>L</u>anguag<u>e</u>" is a
				lightweight template engine in .NET 3.5. It allows you to
				transform structured data into any text-based format output,
				using a simple yet highly extensible template language, thus
				enabling clean separation of document content (data structure)
				and document presentation.</p>
				<p>A simple Cottle template printing how many messages are in
				your mailbox could look like this:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>Hello, {name}!

{if gt(count(messages),0):
    You have {count(messages)} new message{if gt(count(messages),1):s} in your mailbox!
|else:
    You have no new message.
}
</code>
				</div>
				<p>As you can guess by looking at this code, a Cottle template
				contains both "raw" text printed directly and special tags used
				to control how text output is generated. Cottle supports most
				common template engine features, such as:</p>
				<ul>
					<li>Text substitutions through variables,</li>
					<li>Builtin and used-defined functions,</li>
					<li>Variable & function declaration and assignments,</li>
					<li>Conditional statements (if),</li>
					<li>Loops (for, while)</li>
				</ul>
				<p>Source code is available, and contributions will be highly
				welcomed!</p>
			</div>

			<a name="1.2" />
			<h3>1.2. About this documentation</h3>
			<div class="s3">
				<p>This document intent to explain how Cottle works, how to
				write templates and how to use them in your code. Some features
				are introduced with a code sample, and some guidelines have
				been followed to ease readability.</p>
				<p>Using Cottle requires an input template, which could be
				streamed from any source compatible with
				<code>System.IO.TextReader</code> class (text file, memory
				buffer, network socket...), and an executable code that must
				use <code>Cottle.Parser</code> to parse the template into a
				<code>Cottle.Document</code> instance, define values, and
				print the result. These three parts will be shown in examples
				as follows:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>Text contents of the template file 'template.ctl'.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>Document   document;
Parser     parser = new Parser();
FileStream template = new FileStream("template.ctl", FileMode.Open);

using (StreamReader stream = new StreamReader(template, Encoding.UTF8))
{
    document = parser.Parse(stream);
}

/* insert values assignments here */

document.Print(Console.Out);</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Text contents of the template file 'template.ctl'.</code>
				</div>
				<p>Since the sample C# codes used in example is quite redundant
				only the specific parts for each one will appear in examples,
				and should be inserted where indicated by a comment in the
				sample above. Common parts of the code won't be shown anymore.
				</p>
			</div>
		</div>
		
		<a name="2" />
		<h2>2. Template language</h2>
		<div class="s2">
			<a name="2.1" />
			<h3>2.1. Simple raw text output</h3>
			<div class="s3">
				<p>Everything you type into a Cottle template will be printed
				"as is" in the result document, except for some special
				characters. That means raw text will appear exactly as you
				entered it in your template, as shown in this example:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>Hello, world!</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Hello, world!</code>
				</div>
			</div>

			<a name="2.2" />
			<h3>2.2. Sending variables to template</h3>
			<div class="s3">
				<p>To send variables to parsed document so that you can use
				their values in your template, use the <code>Value</code>
				property of <code>Document</code> object. This property is a
				<code>Dictionary&lt;string,Value&gt;</code> in which you can
				create variables by adding their name and value. Implicit
				constructors from some native .NET types are provided so most
				of the time you won't have to explicitly build
				<code>Value</code> objects yourself, but you can check in
				<code>Cottle.Values</code> namespace for available types.</p>

				<p>Once assigned, variables can be used in the template, for
				example by using the <code>echo</code> command that print the
				value of its argument: </p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>Hello {echo name}, you have no new message.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>document.Values["name"] = "John";</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Hello John, you have no new message.</code>
				</div>
				<p>As <code>echo</code> is the default command, you can omit
				the "echo" keyword if the name of the variable you want to
				print doesn't conflict with another command:
				<code>{echo name}</code> is equivalent to <code>{name}</code>
				in this example. This shorter form will be used in all
				incoming samples.</p>
			</div>

			<a name="2.3" />
			<h3>2.3. Escaping special characters</h3>
			<div class="s3">
				<p>There are five special characters that won't be printed
				unless you escape them, since they're used by template parser
				to trigger special behaviours. Special characters are:</p>
				<ul>
					<li>{ and }  (opening and closing braces)</li>
					<li>| (pipe)</li>
					<li>" (quote)</li>
					<li>\ (backslash)</li>
				</ul>
				<p>If you need to print one of these in your template, you must
				preceed them with a backslash character:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>\| Special \"characters\" must \\ be \{escaped\} \|</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>| Special "characters" must \ be {escaped} |</code>
				</div>
				<p>You can also enclose your text between quotes to ignore all
				special characters except " and \:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>"Quoted {text} doesn't |need| escaping, except for other \"quote\" characters."</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Quoted {text} doesn't |need| escaping, except for other "quote" characters.</code>
				</div>
			</div>

			<a name="2.4" />
			<h3>2.4. Using array values</h3>
			<div class="s3">
				<p>Array values contain multiple values stored as key/value
				pairs. Keys and values can be scalar values, or other nested
				array values. Values within an array value can be accessed by
				their key, using either dotted or subscript notation:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>You can use either {myarray.f1} or {myarray["f2"]} notations for array values.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>document.Values["myarray"] = new Dictionary&lt;Value,Value&gt;
{
    {"f1", "dotted"},
    {"f2", "subscript"}
};</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>You can use either dotted or subscript notations for array values.</code>
				</div>
				<p>Please node the quotes used in subscript notation. Trying to
				access value of <code>{myarray[f2]}</code> will result in a
				very different behavior, since it will search for the value
				whose key is the value of <code>f2</code> (which hasn't be
				defined), leading to an undefined result.</p>
				<p>If the keys of two or more pairs are equal, only the value
				of the last one can be accessed directly. However, the other
				pairs can still be retrieved with different methods as we'll
				see later.</p>
			</div>

			<a name="2.5" />
			<h3>2.5. Calling functions</h3>
			<div class="s3">
				<p>Functions in Cottle are special values that can be called
				just like functions in any programming language, using this
				syntax:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>You have {count(messages)} new message(s) in your inbox.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);

document.Values["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "message #0"},
    {1, "message #1"},
    {2, "message #2"}
};</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>You have 3 new message(s) in your inbox.</code>
				</div>
				<p>Please note the use of <code>CommonFunctions.Assign</code>
				method. When a new document is generated by Cottle parser, it
				does not contain any value (thus any function, since functions
				are values). While this gives you full control of which
				functions you want to make available in your templates, you may
				want to start with a set of common predefined functions, and
				that's what <code>CommonFunctions.Assign</code> is made for: it
				just fills <code>document.Value</code> with some useful
				functions without requiring you to implement them manually.</p>
				<p>To get a description of each of the functions set
				when using <code>CommonFunctions.Assign</code>, see paragraph
				"<a href="#5">5. Common functions</a>"</p>
			</div>
		</div>

		<a name="3" />
		<h2>3. Flow control</h2>
		<div class="s2">
			<a name="3.1" />
			<h3>3.1. Conditional statements</h3>
			<div class="s3">
				<p>You can write conditional statements by using the
				<code>if</code> command which evaluate the value of a variable
				(or the result of a function call) to check if its body should
				be printed or not. The <code>if</code> command also supports
				optional <code>elif</code> (else if) and <code>else</code>
				blocks that behave like in any programming language.</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{if 1:
    A condition on a numerical value is true if the value is non-zero.
}

{if test: Variable "test" is true! |else: Variable "test" is false! }

{if gt(count(items), 2):
    There are more than two items in array ({count(items)}, actually).
}

{if lt(x, 0):
    X is negative.
|elif gt(x, 0):
    X is positive.
|else:
    X equals zero.
}</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);

document.Values["items"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "item #0"},
    {1, "item #1"},
    {2, "item #2"}
};

document.Values["test"] = 42;
document.Values["x"] = -3;</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>A condition on a numerical value is true if the value is non-zero.

Variable "test" is true!

There are more than two items in array (3, actually).

X is negative.</code>
				</div>
			</div>

			<a name="3.2" />
			<h3>3.2. Arrays enumeration</h3>
			<div class="s3">
				<p>Pairs contained within an array value can be enumerated
				with the <code>for</code> command, that will print its body for
				each key/value pair it found. An alternative syntax can be used
				if you only want to iterate on values and don't care about
				keys. The <code>for</code> command also supports an optional
				<code>empty</code> block printed when the array you tried to
				enumerate doesn't contain any key/value pair.</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{for index, text in messages:
    Message n°{add(index, 1)}: {text}
|empty:
    No messages to display.
}

Tags: {for tag in tags:{tag} }</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);

document.Values["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "Hi, this is a sample message!"},
    {1, "Hi, me again!"},
    {2, "Hi, guess what?"}
};

document.Values["tags"] = new Value[]
{
    "action",
    "horror",
    "fantastic"
};</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Message n°1: Hi, this is a sample message!
Message n°2: Hi, me again!
Message n°3: Hi, guess what?

Tags: action horror fantastic</code>
				</div>
			</div>

			<a name="3.3" />
			<h3>3.3. Variables assignment</h3>
			<div class="s3">
				<p>You can assign variables while template is being rendered by
				using the <code>set</code> command. Variable assignment allows
				you improve performance by storing evaluation results (such as
				function calls) that are going to be used several times, or
				code complex template mechanism by combining the <code>if</code>,
				<code>for</code> and <code>set</code> commands.</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{set nb_msgs to count(messages)}

{if gt(nb_msgs,0):
    You have {nb_msgs} new message{if gt(nb_msgs, 1):s} in your mailbox!
|else:
    You have no new message.
}

{set nb_long to 0}

{for message in messages:
    {if gt(len(message), 20):
        {set nb_long to add(nb_long, 1)}
    }
}

{nb_long} message{if gt(nb_long, 1):s is|else:" "are} more than 20 characters long.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);

document.Values["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "Hi, this is a sample message!"},
    {1, "Hi, me again!"},
    {2, "Hi, guess what?"}
};</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>You have 3 new messages in your mailbox!

1 message is more than 20 characters long.</code>
				</div>
				<p>You can assume that all variables are set in a global common
				scope. More advanced use of variable assignments will be
				explained later in this document.</p>
			</div>

			<a name="3.4" />
			<h3>3.4. Loops</h3>
			<div class="s3">
				<p>The <code>while</code> command is the equivalent of the
				"while" keyword in most programming languages. Be sure to check
				for a condition that will become false after a finite number of
				iterations, or rendering of your template will never complete.
				When possible, prefer the use of the <code>for</code> command
				over <code>while</code>.</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{set password to ""}
{set nb to rand(8, 16)}
{set i to 0}

{while lt(i, nb):
    {set ascii to rand(62)}

    {if lt(ascii, 10):
        {set password to cat(password, char(add(ascii, ord("0"))))}
    |elif lt(ascii, 36):
        {set password to cat(password, char(add(sub(ascii, 10), ord("A"))))}
    |else:
        {set password to cat(password, char(add(sub(ascii, 36), ord("a"))))}
    }

    {set i to add(i, 1)}
}

Your random password is: {password}.</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Your random password is: 2PIBnodftxz8jAX.</code>
				</div>
			</div>
		</div>

		<a name="4" />
		<h2>4. Advanced topics</h2>
		<div class="s2">
			<a name="4.1" />
			<h3>4.1. Functions declaration</h3>
			<div class="s3">
				<p>Cottle allows you to declare functions, that are callable
				values you can use to factor code as you would do in a program.
				To declare a function and assign it to a variable, use the
				<code>def</code> command that works quite like <code>set</code>
				but have a slightly different syntax. Function arguments are
				specified between parenthesis right after the variable name
				that should receive the function, followed by <code>as</code>
				and function body declaration.</p>
				<p>Functions can return a value that can be used in any
				expression or stored in a variable. To make a function halt and
				return a value, use the <code>return</code> command within its
				body.</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{def factorial(n) as:
    {if gt(n, 1):
        {return mul(n, factorial(sub(n, 1)))}
    |else:
        {return 1}
    }
}

Factorial 1 = {factorial(1)}
Factorial 3 = {factorial(3)}
Factorial 8 = {factorial(8)}

{def hanoi_rec(n, from, by, to) as:
    {set n to sub(n, 1)}

    {if gt(n, 0): {hanoi_rec(n, from, to, by)}}
Move one disk from {from} to {to}
    {if gt(n, 0): {hanoi_rec(n, by, from, to)}}
}

{def hanoi(n) as:
    {hanoi_rec(n, "A", "B", "C")}
}

{hanoi(3)}</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>Factorial 1 = 1
Factorial 3 = 6
Factorial 8 = 40320

Move one disk from peg A to C
Move one disk from peg A to B
Move one disk from peg C to B
Move one disk from peg A to C
Move one disk from peg B to A
Move one disk from peg B to C
Move one disk from peg A to C</code>
				</div>
				<p>You can see in this example that returning a value and
				printing text are two very different things. Raw text within
				function body is printed each time the function is called, or
				more precisely each time its enclosing block is executed (that
				means it won't print if contained in an <code>if</code> command
				that fails to pass, for example). The value returned by the
				function won't be printed unless you explicitly require it by
				using the <code>echo</code> command (e.g. something like
				<code>{factorial(8)}</code>). If a function doesn't use any
				<code>return</code> command, the value it returns is empty,
				that's why the call to <code>{hanoi(3)}</code> in the sample
				above does not print anything more than the raw text blocks it
				contains.</p>
			</div>

			<a name="4.2" />
			<h3>4.2. Variables scopes</h3>
			<div class="s3">
				<p>When writing complex templates using nested or recursive
				functions, you may have to take care of variable scopes to
				avoid potential issues. A scope is the local evaluation context
				of any function or command that have a body. When assigning a
				value to a variable as described in paragraph
				"<a href="#3.3">3.3. Variables assignment</a>", all variables
				belong to the same top-level scope. Consider this template:</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{def range(n) as:
    {if gt(n, 0):
        {set res to cat(range(sub(n, 1)), [n])}
    |else:
        {set res to []}
    }

    {return res}
}

{for v in range(10):
    {v}
}</code>
				</div>
				<p>The <code>range</code> function is expected to return an
				array containing integers from 1 to <code>n</code>,
				<code>n</code> being the value passed as an argument. Of course
				it could be written in a much more efficient way without using
				temporary variables, however we still want this code to return
				a valid result. If you try to execute it, you'll notice that it
				always returns an empty array, no matter what value of
				<code>n</code> you passed.</p>
				<p>When using the <code>set</code> method to assign a value to
				variable <code>res</code>, it always uses the same
				<code>res</code> instance. The <code>range</code> function
				recursively calls itself but overwrite the unique
				<code>res</code> variable each time it tries to store a value
				in it, ending with final <code>{set res to []}</code> that
				always assign it an empty array. To solve this issue, the
				<code>res</code> variable needs to be local <code>range</code>,
				that means each call to <code>range</code> must use its own
				<code>res</code> instance.</p>
				<p>For that reason, the <code>set</code> command actually
				supports two assignment modes:</p>
				<ul>
					<li>When using <code>{set x to 1}</code>, Cottle searches
					for <code>x</code> in parent scopes bottom-up (from inner
					to outer), or create it in global scope if not found.</li>
					<li>When using <code>{set x as 1}</code>, Cottle searches
					for <code>x</code> in current scope, or create it in
					current scope if not found.</li>
				</ul>
				<p>To fix our previous example, <code>set</code> must be used
				with the <code>as</code> keyword before the if <code>if</code>
				block, to initialize a new local <code>res</code> variable. For
				next uses of <code>set</code>, the <code>to</code> keyword will
				still be used since it will now resolve to local
				<code>res</code>:</p>
				<p>FIXME: code sample here</p>
				<p>Two more comments about this code:</p>
				<ul>
					<li>We can't just replace the two <code>to</code> keywords
					by <code>as</code> in original code, since it would create
					local <code>res</code> instances within the <code>if</code>
					statement, leaving them unknown to the <code>return</code>
					command.</li>
					<li>We can't either use <code>as</code> everywhere, because
					it would create new local <code>res</code> instances for
					every new scope where we want to use our function-level
					instance of <code>res</code> within the <code>if</code>
					branches (and that's the <code>to</code> keyword is doing).
				</ul>
				<p>Note that the <code>def</code> command also supports the two
				keywords <code>as</code> and <code>to</code> for the same
				reasons.</p>
			</div>

			<a name="4.3" />
			<h3>4.3. Custom .NET functions</h3>
			<div class="s3">
				<p>FIXME</p>
			</div>
		</div>

		<a name="5" />
		<h2>5. Common functions</h2>
		<div class="s2">
			<h3>5.1. Counting array pairs: count(array)</h3>
			<div class="s3">
				<p>FIXME</p>
			</div>
			<h3>5.x. Sorting array pairs: sort(array[, callback])</h3>
			<div class="s3">
				<p>FIXME</p>
				<div class="code">
					<legend><span>Template:</span></legend>
<code>{set shuffled to ["in", "order", "elements" "natural"]}

{for item in sort(shuffled):
    {item}
}

{def by_length(a, b) as:
    {return cmp(len(b), len(a))}
}

{set shuffled to ["by their", "are sorted", "length", "these strings"]}

{for item in sort(shuffled, by_length):
    {item}
}</code>
				</div>
				<div class="code">
					<legend><span>C# code:</span></legend>
<code>CommonFunctions.Assign(document);</code>
				</div>
				<div class="code">
					<legend><span>Result:</span></legend>
<code>elements
in
natural
order

these strings
are sorted
by their
length</code>
				</div>
			</div>
		</div>

		<a name="6" />
		<h2>6. Contact</h2>
		<div class="s2">
			<h3>6.1. FIXME</h3>
			<div class="s3">
				<p>FIXME</p>
			</div>
		</div>
	</body>
</html>
